\chapter{端子とレジスタ（構成要素）}
\label{chap:term}

次の例題は、NSLで記述する論理回路です。この例題も、シミュレーション専用であり、コンパイルしても、電子回路とはなりません。この回路をtut1.nslという名前のテキストファイルとして用意してください。

\reviewlistcaption{リスト2.1: tut1}
\begin{reviewlist}
\begin{alltt}
declare tut1 simulation \{ \}
module tut1 \{
   reg count[8] = 0;
   count++;
   if(count==100) \textunderscore{}display("Hello World");
   if(count==200) \textunderscore{}finish("bye");
\}
\end{alltt}
\end{reviewlist}


module文の中に、内部で用いる端子やレジスタなどの構成要素と実現する回路を記述します。例題では、構成要素として8ビットのレジスタcountを定義して、その初期値を0としています。また、レジスタはクロックごとにカウントアップし、カウント値が100の時と200の時に、それぞれ\textunderscore{}display文と\textunderscore{}finish文を実行します。

大規模な回路を開発する場合、論理回路の各モジュールを同期回路として設計します。そこで、NSLは、通常、クロック信号を明示的には書きません。クロックやリセットの信号は、いわば上水道や下水道などのインフラにあたり、設計者が通常意識する必要がないからです。後述するように、必要に応じて、これらの信号を用い、同期回路同士を異なるクロックやリセットの信号で動かすこともできます。

プログラム言語における変数に相当する演算のための要素として、ハードウェア設計者は、回路中のネット（配線）に名前をつけます。この名前のついたネットを端子と呼び、演算において、端子名を記述することで、その値を参照します。NSLでは、モジュールの内外を接続するための、入力端子や出力端子のほかに、モジュール内部の演算処理のための内部端子を用います。ネットの信号は、駆動されている間だけ電位を保ちますが、記憶素子（レジスタ、メモリ）の出力ネットだけは、電源が入っている間中、記憶内容を保ち続けるため、データを保持する特別の存在として扱います。

NSLにおいてモジュール内部で宣言する、ハードウェアに展開する基本的な構成要素は、次の3種類です。（他モジュールのインスタンスや整数、変数、構造体などの構成要素は別途説明します。）すべての構成要素は、実行文の前に宣言する必要があります。宣言では、構成要素の種類を示すキーワードに続けて、要素名とビット幅を指定します。

\begin{enumerate}
\item レジスタ  : レジスタは reg  レジスタ名[ビット幅]; と、名前とビット幅を指定します。セミコロンの前に = 値 として初期値を設定可能です。ビット幅を省略すると1ビットとみなします。レジスタはデータを記憶する素子です。レジスタに記憶されたデータは、明示的に変更されるまで同じ値を保ちます。
\item 内部端子 : 内部端子は wire 内部端子名[ビット幅]; と、レジスタ同様に名前とビット幅を指定します。ビット幅を省略すると1ビットとみなします。内部端子は、転送を受けたクロックサイクルの間だけ、データを保持します。
\item メモリ : メモリは、mem メモリ名[ワード数][ビット幅]; と、名前とワード数、ビット幅を指定します。  mem mm[256][8] = \{ 3, 2, 5 \} のように、初期値を設定可能です。メモリはレジスタを配列上に並べて、その番号で値を読み書きする素子です。
\end{enumerate}

内部端子への値の転送は、転送が記述された条件のクロック内に行い、レジスタ、メモリへの値の転送は、次のクロックの立ち上がりに同期して実行します。 静的な主記憶領域を前提としたソフトウェアでは、変数の型の主な目的は主記憶上の記憶領域の大きさを指定することです。ハードウェアは、ソフトウェアと異なり、物理的な回路の大きさと、回路の機能を指定する必要があります。そこで、NSLは、回路機能として、レジスタ、内部端子、メモリの3つを提供します。

ハードウェアの特徴として、記述した回路は同時並列に動作します。そこで、回路の動作を条件によって選択的に行うための条件実行の構文を用意しました。条件実行は、条件付実行文のほかに、関数や手続き、状態があります。これらのの制御機構によって、回路動作の振る舞いを調整し、必要な機能を実現します。特に関数には、モジュール内部に完結する制御のほか、他のモジュールと連携を取るための外部からの／への制御があります。

ハードウェアに設計では、クロックの遷移する瞬間の動的なデータ変化が重要です。設計者は、内部構成要素のデータが、どのクロックで有効になるのかを常に把握しておく必要があります。

NSLには、回路として実現する記述の他に、論理シミュレーションを支援するための構文があります。この例題のdeclare文に書いた simulation の修飾は、このモジュールが論理合成対象ではなく、シミュレーション時にのみ有効であることを示します。また、\textunderscore{}displayと\textunderscore{}finishは、どちらもシミュレーション支援の組込み関数です。

シミュレーションを実行するために、この回路を、NSL COREでコンパイルします。

\begin{reviewcmd}
\begin{alltt}
\textgreater{} nsl2vl tut1.nsl -verisim2 -target tut1
\end{alltt}
\end{reviewcmd}

この操作で、tut1.vというVerilogHDLのファイルができます。

次に、Icarus Verilogで、コンパイルします。

\begin{reviewcmd}
\begin{alltt}
\textgreater{} iverilog -o tut1.vvp tut1.v
\end{alltt}
\end{reviewcmd}

それでは、実行してみましょう。

\begin{reviewcmd}
\begin{alltt}
\textgreater{} vvp tut1.vvp

VCD info: dumpfile tut1.vcd opened for output.
Hello World
bye
\end{alltt}
\end{reviewcmd}

この回路記述が出力しているのは、Hello Worldとbyeの2行になります。

NSLは同時並列実行を行っているので、メッセージを出力する順序は、順序を作るための回路より生成します。例題では、countというレジスタをクロックごとにカウントアップして、その値によって実行する文を切り替えます。プログラム言語は、記述した順序で実行しますが、ハードウェアは並列動作を基本とすることから、このような手続きが必要になります。（VerilogHDLのようにシミュレーションのためだけに、順序実行のための記述を持つHDLもあります）

\section{メモリ例題}

次の例題はメモリと、メモリの初期化を用いた例題になります。この例題で用いる文法の一部は、まだ説明していませんので、チュートリアルの最後にもう一度読み直してみてください。

\reviewlistcaption{リスト2.2: tut20}
\begin{reviewlist}
\begin{alltt}
declare tut20 simulation \{ \}
module tut20 \{
    reg count[8] = 0;
    mem m[256][8];
    func\textunderscore{}self readm();

    \textunderscore{}init \{
        readm();
        \textunderscore{}display("Hello World:m[1]=\%x", m[1]);
        \textunderscore{}finish("bye");
	\}

function readm \{
        \textunderscore{}display("readmem:\%d", count);
    \textunderscore{}readmemh("tut20.hex",m);
\}
\}
\end{alltt}
\end{reviewlist}

